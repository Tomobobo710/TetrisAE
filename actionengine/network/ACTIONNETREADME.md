# ActionNet - Networking for ActionEngine

A complete multiplayer networking solution for ActionEngine games, providing:

- **ActionNetManager**: Client-side WebSocket manager with room/lobby system
- **ActionNetServerUtils**: Server-side utilities for client and room management
- **SyncSystem**: Generic state synchronization for client-to-client data sharing

## Client Identity System

ActionNet provides a clean client identity system with two key concepts:

### 1. **Client ID** (Unique Identifier)
- Auto-generated unique identifier for internal tracking
- Format: `client_1234567890` (unless custom ID provided)
- Never changes during connection
- Used for data lookups and internal logic

### 2. **Username** (User-Provided Name)
- Human-readable name provided by the user
- What users type when connecting (e.g., "Alice", "Player123")
- Can be changed during session with `setUsername()`
- May not be unique (multiple users can request same name)

### 3. **Display Name** (Server-Generated Unique Name)
- **Auto-generated by server** to ensure uniqueness
- Based on username but made unique with suffixes
- Examples:
  - First "Player" → `"Player"`
  - Second "Player" → `"Player (1)"`
  - Third "Player" → `"Player (2)"`
- **This is what you should show in your UI**
- Automatically updated in user lists

## Quick Start - Client Side

```javascript
// Create network manager with configuration
const net = new ActionNetManager({
    url: 'ws://localhost:8000',
    autoConnect: false,
    reconnect: true,
    debug: true
});

// Connect with a username
await net.connectToServer({
    username: 'Player123'      // User-friendly name
});

// Query client identity
console.log('Client ID:', net.getClientId());         // "client_1234567890"
console.log('Username:', net.getUsername());           // "Player123"

// Join a room
await net.joinRoom('game-room-1');

// Check if you're the host
if (net.isCurrentUserHost()) {
    console.log('You are the host!');
}

// Change username anytime
await net.setUsername('NewName');

// Get display names of all users in room
const users = net.getConnectedUsers();
users.forEach(user => {
    console.log(user.displayName);  // Use displayName for UI!
});
```

## Server Side

```javascript
const WebSocket = require('ws');
const ActionNetServerUtils = require('./ActionNetServerUtils');

const wss = new WebSocket.Server({ port: 8000 });
const utils = new ActionNetServerUtils(wss);

wss.on('connection', (ws) => {
    ws.on('message', (data) => {
        const msg = JSON.parse(data.toString());
        
        if (msg.type === 'connect') {
            // Register client - automatically generates unique displayName
            utils.registerClient(ws, msg);

            // Get client info
            const client = utils.getClient(ws);
            console.log('Client ID:', client.id);              // Unique ID
            console.log('Username:', client.username);          // User-provided
            console.log('Display Name:', client.displayName);   // Server-generated unique
        }

        if (msg.type === 'chat') {
            const client = utils.getClient(ws);

            // Broadcast with display name
            utils.broadcastToRoom(client.roomName, {
                type: 'chat',
                displayName: client.displayName,   // ← Use displayName for UI
                text: msg.text
            });
        }
    });
});
```

## Host System

### How It Works

- **First person to join a room becomes the host**
- Host info is included in user lists: `{ id, username, displayName, isHost: true }`
- When host leaves or disconnects, the room closes and all players return to lobby
- Non-host players leaving doesn't affect the room

### Client API

```javascript
// Check if current user is the host
if (net.isCurrentUserHost()) {
    console.log('You are the host - you can start the game!');
    showStartButton();
}

// Get the host's info
const host = net.getHost();
if (host) {
    console.log('Host:', host.displayName);
}

// Listen for host leaving
net.on('hostLeft', (msg) => {
    console.log('Host left - returning to lobby');
    showLobbyScreen();
});
```

### Server API

```javascript
// Check if a client is the host
if (utils.isHost(ws)) {
    console.log('This client is the host!');
}

// Get host info for a room
const host = utils.getHostOfRoom('game-room-1');
console.log('Host:', host.displayName);
```

## SyncSystem - State Synchronization

`SyncSystem` provides a simple way to synchronize state between clients without writing custom sync logic for every field.

### How It Works

1. Register **sync sources** with `getFields()` methods
2. SyncSystem broadcasts your local data periodically
3. SyncSystem receives remote data and emits events
4. Query remote state anytime with `getRemote(id)`

### Basic Usage

```javascript
// Create sync system with transport
const sync = new SyncSystem({
    send: (msg) => net.send(msg),
    broadcastInterval: 16,    // Broadcast every 16ms (~60fps)
    staleThreshold: 200        // Consider remote stale after 200ms
});

// Register sync sources
sync.register('player', {
    getFields: () => ({
        score: player.score,
        level: player.level,
        alive: !player.gameOver
    })
});

sync.register('match', {
    getFields: () => ({
        state: matchStateMachine.getState(),
        ready: isReady,
        timeRemaining: timer.remaining
    })
});

// Listen for remote updates
sync.on('remoteUpdated', (allRemoteData) => {
    // All remote data changed
    updateOpponentDisplay();
});

sync.on('remoteStale', () => {
    console.warn('Opponent stopped responding');
    showDisconnectedWarning();
});

sync.on('remoteFresh', () => {
    console.log('Opponent reconnected');
    hideDisconnectedWarning();
});

// Start syncing
sync.start();

// Hook up incoming sync messages
net.on('syncUpdate', (msg) => {
    sync.handleSyncUpdate(msg);
});

// Query remote data
const remotePlayer = sync.getRemote('player');
if (remotePlayer) {
    opponentScore.text = remotePlayer.score;
    opponentLevel.text = remotePlayer.level;
}

// Or get specific fields
const opponentScore = sync.getRemoteField('player', 'score');

// Check staleness
if (sync.isRemoteStale()) {
    showWaitingForOpponent();
}

// Stop syncing
sync.stop();
```

### Advanced Usage

```javascript
// Multiple sync sources
sync.register('player', { getFields: () => ({...}) });
sync.register('camera', { getFields: () => ({...}) });
sync.register('gameState', { getFields: () => ({...}) });

// Force immediate broadcast (outside normal interval)
sync.forceBroadcast();

// Clear remote data when opponent disconnects
net.on('userLeft', () => {
    sync.clearRemoteData();
});

// Check if we've ever received data
if (sync.hasRemoteData()) {
    console.log('Opponent is syncing');
}

// Get time since last update
const ms = sync.getTimeSinceLastUpdate();
console.log(`Last update ${ms}ms ago`);

// Get list of registered sources
const sources = sync.getRegisteredSources();
console.log('Syncing:', sources);  // ['player', 'camera', 'gameState']
```

## Ping and RTT Tracking

ActionNetManager includes built-in ping/pong for connection health and latency tracking.

```javascript
// Enable ping with configuration
const net = new ActionNetManager({
    url: 'ws://localhost:8000',
    pingInterval: 30000,    // Ping every 30 seconds
    pongTimeout: 5000       // Expect pong within 5 seconds
});

// Get current round-trip time
const rtt = net.getRTT();
console.log(`Ping: ${rtt}ms`);

// Listen for RTT updates
net.on('rtt', (rtt) => {
    pingDisplay.text = `${rtt}ms`;
    if (rtt > 200) {
        showLagWarning();
    }
});

// Listen for timeout (pong not received)
net.on('timeout', () => {
    console.warn('Connection timeout - may be disconnected');
});
```

## Auto-Reconnection

ActionNetManager supports automatic reconnection with exponential backoff.

```javascript
const net = new ActionNetManager({
    url: 'ws://localhost:8000',
    reconnect: true,              // Enable auto-reconnect
    reconnectDelay: 1000,         // Start with 1 second delay
    maxReconnectDelay: 30000,     // Cap at 30 seconds
    reconnectAttempts: -1         // -1 = infinite attempts
});

// Listen for reconnection events
net.on('reconnecting', ({ attempt, delay }) => {
    console.log(`Reconnecting... attempt ${attempt} in ${delay}ms`);
    showReconnectingMessage(attempt);
});

net.on('connected', () => {
    console.log('Reconnected!');
    hideReconnectingMessage();
});

net.on('reconnectFailed', () => {
    console.log('Max reconnect attempts reached');
    showConnectionFailedMessage();
});

// Get current reconnect attempt count
const attempts = net.getReconnectAttempts();
console.log(`Reconnect attempts: ${attempts}`);
```

### Exponential Backoff

Reconnect delays increase exponentially:
- Attempt 1: 1 second
- Attempt 2: 2 seconds
- Attempt 3: 4 seconds
- Attempt 4: 8 seconds
- Attempt 5: 16 seconds
- Attempt 6+: 30 seconds (capped at maxReconnectDelay)

## Best Practices

### ✅ DO:
```javascript
// Use displayName for anything users see
chatMessage.text = `${user.displayName}: ${text}`;
userListItem.text = user.displayName;
scoreboard.add(user.displayName, score);

// Use client ID for internal tracking
playerData[user.id] = { score: 100 };
entityMap.set(user.id, entity);

// Check host status for game logic
if (net.isCurrentUserHost()) {
    // Only host can start the game
    showStartButton();
}
```

### ❌ DON'T:
```javascript
// Don't show client IDs to users
chat.addMessage(client.id, text);  // Shows "client_1234567890" - confusing!

// Don't use usernames as unique keys
playerData[client.username] = data;  // Can conflict if names aren't unique!

// Don't use username for display
chat.text = client.username;  // Use displayName instead!
```

## API Reference

### ActionNetManager (Client)

#### Connection
```javascript
net.connectToServer({ username: 'Bob' })     // Returns Promise
net.disconnect()
net.isConnected()                             // Returns Boolean
net.connectionFailed()                        // Returns Boolean
net.testServerConnection()                    // Returns Promise<{available, error}>
```

#### Room Management
```javascript
net.joinRoom('lobby')                         // Returns Promise
net.leaveRoom()
net.isInRoom()                                // Returns Boolean
net.getCurrentRoomName()                      // Returns String|null
net.getAvailableRooms()                       // Returns Array<String>
```

#### Identity
```javascript
net.getClientId()                             // Returns String (unique ID)
net.getUsername()                             // Returns String (user-provided)
net.setUsername(name)                         // Returns Promise (sends to server)
```

#### Host System
```javascript
net.isCurrentUserHost()                       // Returns Boolean
net.getHost()                                 // Returns Object|null
```

#### Messaging
```javascript
net.send({ type: 'chat', text: 'Hello!' })   // Returns Boolean
net.on(event, handler)                        // Register event listener
net.off(event, handler)                       // Remove event listener
net.emit(event, ...args)                      // Emit event (internal use)
```

#### State Queries
```javascript
net.getConnectedUsers()                       // Returns Array<Object>
net.getNewMessages()                          // Returns Array (polling pattern)
net.getRTT()                                  // Returns Number (milliseconds)
net.getReconnectAttempts()                    // Returns Number
```

### ActionNetServerUtils (Server)

#### Client Management
```javascript
utils.registerClient(ws, data)                // Returns Boolean
utils.getClient(ws)                           // Returns Object|null
utils.handleDisconnect(ws)                    // Returns Object|null
utils.getTotalClients()                       // Returns Number
utils.generateUniqueDisplayName(username, excludeId)  // Returns String
```

#### Room Management
```javascript
utils.addToRoom(ws, roomName)                 // Returns Boolean
utils.removeFromRoom(ws, returnToLobby)       // Returns String|null
utils.getRoomList()                           // Returns Array<String>
utils.roomExists(roomName)                    // Returns Boolean
utils.getRoomSize(roomName)                   // Returns Number
utils.getRoomInfo(roomName)                   // Returns Object|null
utils.getClientsInRoom(roomName)              // Returns Array (with displayName)
utils.getClientDetailsInRoom(roomName)        // Returns Array (full details)
utils.getLobbySize()                          // Returns Number
```

#### Host System
```javascript
utils.isHost(ws)                              // Returns Boolean
utils.getHostOfRoom(roomName)                 // Returns Object|null
```

#### Broadcasting
```javascript
utils.sendToClient(ws, message)               // Send to one client
utils.broadcastToRoom(roomName, message, excludeWs)     // Send to room
utils.broadcastToAll(message, excludeWs)      // Send to all clients
utils.broadcastToLobby(message, excludeWs)    // Send to lobby only
```

### SyncSystem (Client)

#### Setup
```javascript
const sync = new SyncSystem({ send, broadcastInterval, staleThreshold })
sync.register(id, source)                     // Returns Boolean
sync.unregister(id)                           // Returns Boolean
sync.start()                                  // Start broadcasting
sync.stop()                                   // Stop broadcasting
```

#### Events
```javascript
sync.on(event, handler)                       // Register listener
sync.off(event, handler)                      // Remove listener
// Events: 'remoteUpdated', 'remoteStale', 'remoteFresh', 'broadcast'
```

#### Querying Remote Data
```javascript
sync.getRemote(id)                            // Returns Object|null
sync.getRemoteField(sourceId, field)          // Returns Any|null
sync.getAllRemote()                           // Returns Object
```

#### State Checks
```javascript
sync.isRemoteStale()                          // Returns Boolean
sync.hasRemoteData()                          // Returns Boolean
sync.getTimeSinceLastUpdate()                 // Returns Number (ms)
sync.getRegisteredSources()                   // Returns Array<String>
```

#### Manual Control
```javascript
sync.forceBroadcast()                         // Broadcast immediately
sync.clearRemoteData()                        // Clear remote state
sync.handleSyncUpdate(message)                // Process incoming sync
```

## Events Reference

### ActionNetManager Events

- `connected`: `() => {}` - Connected to server
- `disconnected`: `() => {}` - Disconnected from server
- `error`: `(error) => {}` - Connection or server error
- `message`: `(msg) => {}` - Any message received
- `roomList`: `(rooms) => {}` - Available rooms updated
- `userList`: `(users) => {}` - Users in room updated
- `joinedRoom`: `(roomName) => {}` - Successfully joined room
- `leftRoom`: `(roomName) => {}` - Left room
- `userJoined`: `(user) => {}` - Someone joined your room
- `userLeft`: `(user) => {}` - Someone left your room
- `hostLeft`: `(msg) => {}` - Host left, room closing
- `usernameChanged`: `({oldUsername, newUsername, displayName}) => {}` - Username changed
- `chat`: `(msg) => {}` - Chat message received
- `system`: `(msg) => {}` - System message received
- `rtt`: `(milliseconds) => {}` - Round-trip time updated
- `timeout`: `() => {}` - Pong not received (connection issue)
- `reconnecting`: `({attempt, delay}) => {}` - Attempting to reconnect
- `reconnectFailed`: `() => {}` - Max reconnect attempts reached
- Custom events based on `message.type`

### SyncSystem Events

- `remoteUpdated`: `(remoteData) => {}` - Remote data received
- `remoteStale`: `() => {}` - Remote stopped sending updates
- `remoteFresh`: `() => {}` - Remote resumed after being stale
- `broadcast`: `(localData) => {}` - We broadcasted data

## Example: Complete Multiplayer Game

```javascript
class MultiplayerGame {
    constructor() {
        // Network manager
        this.net = new ActionNetManager({
            url: 'ws://localhost:8000',
            reconnect: true,
            debug: true
        });
        
        // Sync system
        this.sync = new SyncSystem({
            send: (msg) => this.net.send(msg),
            broadcastInterval: 16,
            staleThreshold: 200
        });
        
        this.setupNetworkListeners();
        this.setupSyncSources();
    }
    
    setupNetworkListeners() {
        this.net.on('connected', () => {
            console.log('Connected to server');
            this.showLobby();
        });
        
        this.net.on('userList', (users) => {
            this.updateUserList(users);
        });
        
        this.net.on('hostLeft', () => {
            this.returnToLobby('Host left the game');
        });
        
        // Route sync messages to sync system
        this.net.on('syncUpdate', (msg) => {
            this.sync.handleSyncUpdate(msg);
        });
        
        // Custom game messages
        this.net.on('gameStart', (msg) => {
            this.startGame();
        });
    }
    
    setupSyncSources() {
        this.sync.register('player', {
            getFields: () => ({
                x: this.player.x,
                y: this.player.y,
                score: this.player.score,
                health: this.player.health
            })
        });
        
        this.sync.on('remoteUpdated', (data) => {
            this.updateOpponent(data.player);
        });
        
        this.sync.on('remoteStale', () => {
            this.showOpponentDisconnected();
        });
    }
    
    async login(username) {
        await this.net.connectToServer({ username });
    }
    
    async createRoom(roomName) {
        await this.net.joinRoom(roomName);
        this.sync.start();
    }
    
    startGame() {
        // Only host can start
        if (this.net.isCurrentUserHost()) {
            this.net.send({ type: 'gameStart' });
        }
    }
    
    updateUserList(users) {
        this.userListUI.clear();
        users.forEach(user => {
            this.userListUI.add(user.displayName, user.isHost);
        });
    }
    
    updateOpponent(opponentData) {
        this.opponent.x = opponentData.x;
        this.opponent.y = opponentData.y;
        this.opponent.score = opponentData.score;
    }
}
```

## Example: Multiplayer Game with State Machine and Multiple Sync Sources

This example shows a more realistic multiplayer game session using a state machine and multiple sync sources, similar to how NetworkSession.js orchestrates a Tetris battle.

```javascript
class MultiplayerGameSession {
    constructor(net, gameManager, gui) {
        this.net = net;           // ActionNetManager instance
        this.gameManager = gameManager;
        this.gui = gui;
        
        // State machine: WAITING → COUNTDOWN → PLAYING → GAME_OVER → REMATCH_PENDING
        this.state = 'WAITING';
        this.countdownTimer = 3;
        this.ready = false;  // Local player ready status
        this.rematchRequested = false;
        
        // Sync system for continuous state broadcasting
        this.sync = new SyncSystem({
            send: (msg) => this.net.send(msg),
            broadcastInterval: 16,    // 60fps
            staleThreshold: 200       // 12 frames at 60fps
        });
        
        this.setupNetworkListeners();
    }
    
    setupNetworkListeners() {
        // Listen for user list updates to get opponent info
        this.net.on('userList', (users) => {
            const opponent = users.find(u => u.id !== this.net.getClientId());
            if (opponent) {
                this.updateOpponentName(opponent.displayName);
            }
            this.checkStartConditions();
        });
        
        // Handle opponent disconnection
        this.net.on('userLeft', (user) => {
            this.handleOpponentLeft(user);
        });
        
        // Handle host leaving (room closes)
        this.net.on('hostLeft', (msg) => {
            this.handleHostLeft(msg);
        });
        
        // Handle custom game messages (attacks, powerups, etc.)
        this.net.on('attack', (msg) => {
            this.handleAttackReceived(msg);
        });
    }
    
    start() {
        console.log('[Session] Starting multiplayer session...');
        
        // Initialize players
        this.localPlayer = this.gameManager.createPlayer(1, true);
        this.remotePlayer = this.gameManager.createPlayer(2, false);
        
        // Mark as ready immediately (new joiners start ready)
        this.ready = true;
        
        // Register multiple sync sources for different aspects of game state
        
        // 1. Match state - high-level game flow
        this.sync.register('match', {
            getFields: () => ({
                state: this.state,
                ready: this.ready,
                wantsRematch: this.rematchRequested
            })
        });
        
        // 2. Player gameplay stats
        this.sync.register('gameplay', {
            getFields: () => ({
                alive: !this.localPlayer.gameOver,
                score: this.localPlayer.score,
                level: this.localPlayer.level,
                health: this.localPlayer.health
            })
        });
        
        // 3. Player position and movement
        this.sync.register('position', {
            getFields: () => ({
                x: this.localPlayer.x,
                y: this.localPlayer.y,
                velocityX: this.localPlayer.velocityX,
                velocityY: this.localPlayer.velocityY,
                facing: this.localPlayer.facing
            })
        });
        
        // 4. Player abilities/powerups
        this.sync.register('abilities', {
            getFields: () => ({
                activePowerup: this.localPlayer.activePowerup,
                powerupTimer: this.localPlayer.powerupTimer,
                canUseSpecial: this.localPlayer.canUseSpecial
            })
        });
        
        // 5. Inventory or equipment
        this.sync.register('inventory', {
            getFields: () => ({
                weapon: this.localPlayer.currentWeapon,
                ammo: this.localPlayer.ammo,
                items: this.localPlayer.inventory.slice(0, 5)
            })
        });
        
        // Listen for remote updates
        this.sync.on('remoteUpdated', (allRemoteData) => {
            // Check if we can start the game
            this.checkStartConditions();
            
            // Check rematch conditions
            this.checkRematchConditions();
            
            // Update remote player from synced data
            this.updateRemotePlayer(allRemoteData);
        });
        
        this.sync.on('remoteStale', () => {
            console.warn('[Session] Opponent connection is unstable');
            this.showLagWarning();
        });
        
        this.sync.on('remoteFresh', () => {
            console.log('[Session] Opponent connection restored');
            this.hideLagWarning();
        });
        
        // Start syncing
        this.sync.start();
        
        // Start in WAITING state
        this.state = 'WAITING';
        this.checkStartConditions();
    }
    
    checkStartConditions() {
        // Only auto-start from WAITING state
        if (this.state !== 'WAITING') return;
        
        const users = this.net.getConnectedUsers();
        const remoteMatch = this.sync.getRemote('match');
        const remoteReady = remoteMatch ? remoteMatch.ready : false;
        
        console.log('[Session] Checking start conditions:', {
            users: users.length,
            localReady: this.ready,
            remoteReady: remoteReady,
            remoteStale: this.sync.isRemoteStale()
        });
        
        // Start if: 2+ players, both ready, remote data not stale
        if (users.length >= 2 && this.ready && remoteReady && !this.sync.isRemoteStale()) {
            this.startCountdown();
        }
    }
    
    startCountdown() {
        console.log('[Session] Starting countdown...');
        this.state = 'COUNTDOWN';
        this.countdownTimer = 3;
        this.resetGameState();
    }
    
    update(deltaTime) {
        switch (this.state) {
            case 'COUNTDOWN':
                this.countdownTimer -= deltaTime;
                if (this.countdownTimer <= 0) {
                    this.startGame();
                }
                break;
                
            case 'PLAYING':
                // Check for game over
                if (this.checkGameOver()) {
                    this.endGame();
                }
                break;
        }
    }
    
    startGame() {
        console.log('[Session] Game started!');
        this.state = 'PLAYING';
    }
    
    checkGameOver() {
        // Game over when only one player is alive
        const localAlive = !this.localPlayer.gameOver;
        const remoteGameplay = this.sync.getRemote('gameplay');
        const remoteAlive = remoteGameplay ? remoteGameplay.alive : true;
        
        return !localAlive || !remoteAlive;
    }
    
    endGame() {
        console.log('[Session] Game over!');
        this.state = 'GAME_OVER';
        this.rematchRequested = false;
        
        // Determine winner
        const localAlive = !this.localPlayer.gameOver;
        const winner = localAlive ? this.localPlayer : this.remotePlayer;
        this.gameManager.showGameOver(winner);
    }
    
    requestRematch() {
        if (this.state !== 'GAME_OVER') return false;
        
        console.log('[Session] Requesting rematch...');
        this.rematchRequested = true;
        this.state = 'REMATCH_PENDING';
        this.checkRematchConditions();
        return true;
    }
    
    checkRematchConditions() {
        if (this.state !== 'REMATCH_PENDING' && this.state !== 'GAME_OVER') return;
        
        const remoteMatch = this.sync.getRemote('match');
        const remoteWantsRematch = remoteMatch ? remoteMatch.wantsRematch : false;
        
        // Both want rematch?
        if (this.rematchRequested && remoteWantsRematch) {
            console.log('[Session] Both players want rematch - starting!');
            this.startRematch();
        }
    }
    
    startRematch() {
        console.log('[Session] Starting rematch!');
        this.resetGameState();
        this.startCountdown();
    }
    
    resetGameState() {
        // Reset both players
        this.localPlayer.reset();
        this.remotePlayer.reset();
        this.gameManager.reset();
    }
    
    updateRemotePlayer(allRemoteData) {
        // Update remote player from multiple sync sources
        const gameplay = allRemoteData.gameplay;
        if (gameplay) {
            this.remotePlayer.score = gameplay.score;
            this.remotePlayer.level = gameplay.level;
            this.remotePlayer.health = gameplay.health;
            this.remotePlayer.gameOver = !gameplay.alive;
        }
        
        const position = allRemoteData.position;
        if (position) {
            this.remotePlayer.x = position.x;
            this.remotePlayer.y = position.y;
            this.remotePlayer.velocityX = position.velocityX;
            this.remotePlayer.velocityY = position.velocityY;
            this.remotePlayer.facing = position.facing;
        }
        
        const abilities = allRemoteData.abilities;
        if (abilities) {
            this.remotePlayer.activePowerup = abilities.activePowerup;
            this.remotePlayer.powerupTimer = abilities.powerupTimer;
        }
        
        const inventory = allRemoteData.inventory;
        if (inventory) {
            this.remotePlayer.currentWeapon = inventory.weapon;
            this.remotePlayer.ammo = inventory.ammo;
        }
    }
    
    handleAttackReceived(msg) {
        console.log('[Session] Received attack from opponent:', msg.damage);
        this.localPlayer.takeDamage(msg.damage, msg.attackType);
    }
    
    sendAttack(damage, attackType) {
        this.net.send({
            type: 'attack',
            damage: damage,
            attackType: attackType,
            timestamp: Date.now()
        });
    }
    
    handleOpponentLeft(user) {
        console.log('[Session] Opponent left');
        
        if (this.state === 'WAITING') return;
        
        // Reset and wait for new opponent (if host)
        if (this.net.isCurrentUserHost()) {
            this.ready = false;
            this.state = 'WAITING';
            this.showWaitingForOpponent();
        }
    }
    
    handleHostLeft(msg) {
        console.log('[Session] Host left - room closing');
        this.gameManager.showRoomClosedMessage();
        this.cleanup();
    }
    
    cleanup() {
        console.log('[Session] Cleaning up...');
        this.sync.stop();
        this.sync = null;
    }
}
```

### Key Patterns Demonstrated

1. **State Machine**: Clear state transitions for game flow
2. **Multiple Sync Sources**: Different aspects of game state broken into logical sources
3. **Ready Coordination**: Both players must be ready before countdown starts
4. **Staleness Detection**: Monitor opponent connection health
5. **Rematch Logic**: Coordinated rematch using synced flags
6. **Host/Guest Handling**: Different behavior for host vs joiner on disconnect
7. **Custom Messages**: Use both sync (continuous) and messages (events) appropriately

### When to Use Sync vs Messages

**Use SyncSystem for:**
- Continuous state (position, health, score)
- Frequently changing data
- Data that can tolerate dropped packets
- State that needs to "catch up" automatically

**Use custom messages for:**
- One-time events (attack, powerup collected, chat)
- Critical actions that must not be lost
- Large infrequent data (level loaded, match results)
- Actions requiring acknowledgment

## See Also

- Example server: `game/server/ActionNetServer.js`
- Server README: `game/server/README.md`
- Run server: `game/server/start.bat` (Windows) or `game/server/start.sh` (Mac/Linux)