# ActionNet - Networking for ActionEngine

A complete multiplayer networking solution for ActionEngine games, providing:

- **ActionNetManager**: Client-side WebSocket manager with room/lobby system
- **ActionNetManagerP2P**: Peer-to-peer networking with DHT discovery and WebRTC
- **ActionNetManagerGUI**: Unified GUI supporting both WebSocket and P2P modes
- **ActionNetServerUtils**: Server-side utilities for client and room management
- **SyncSystem**: Generic state synchronization for client-to-client data sharing

## Client Identity System

ActionNet provides a clean client identity system with three key concepts:

### 1. **Client ID** (Unique Identifier)
- Auto-generated unique identifier for internal tracking
- Format: `client_1234567890` (WebSocket) or `peer_abc123def` (P2P)
- Never changes during connection
- Used for data lookups and internal logic

### 2. **Username** (User-Provided Name)
- Human-readable name provided by the user
- What users type when connecting (e.g., "Alice", "Player123")
- Can be changed during session with `setUsername()`
- May not be unique (multiple users can request same name)

### 3. **Display Name** (Server-Generated Unique Name)
- Auto-generated by server/peer to ensure uniqueness
- Based on username but made unique with suffixes
- Examples:
  - First "Player" → `"Player"`
  - Second "Player" → `"Player (1)"`
  - Third "Player" → `"Player (2)"`
- **This is what you should show in your UI**
- Automatically updated in user lists

## Quick Start - WebSocket Mode

```javascript
// Create and connect
const net = new ActionNetManager({
    url: 'ws://yourserver.com:3000',
    reconnect: true,
    debug: true
});

net.on('connected', () => console.log('Connected!'));
net.on('roomList', (rooms) => console.log('Available rooms:', rooms));

// Connect with username
await net.connectToServer({ username: 'Player123' });

// Join a room
await net.joinRoom('lobby-1');

// Listen for other players
net.on('userList', (users) => {
    users.forEach(user => {
        console.log(`${user.displayName} (ID: ${user.id})`);
    });
});

// Send messages
net.send({ type: 'chat', text: 'Hello!' });
```

## Quick Start - P2P Mode (No Server Required)

P2P mode uses bittorrent trackers for peer discovery - no central server needed.

```javascript
// Initialize GUI with P2P mode - handles lobby UI
const gui = new ActionNetManagerGUI(canvases, input, audio, { mode: 'p2p' });

// Listen for when user creates/joins a room
gui.on('joinedRoom', (roomName) => {
    console.log('Joined room:', roomName);
    // Get the network manager and data channel
    const net = gui.getNetManager();
    const dataChannel = net.getDataChannel();
    // Your game session starts here
});

gui.on('leftRoom', () => {
    console.log('Left room');
});

// Update GUI each frame
gui.action_update(deltaTime);
gui.action_draw();
```

Or integrate P2P directly:

```javascript
const net = new ActionNetManagerP2P({ gameId: 'tetris-1v1', debug: true });

// Join DHT network and search for rooms
await net.joinGame('tetris-1v1', 'Player123');

// Listen for discovered rooms
net.on('roomList', (rooms) => {
    rooms.forEach(room => {
        console.log(`${room.username}'s room: ${room.currentPlayers}/${room.maxPlayers} players`);
    });
});

// Create your own room (become host)
net.createRoom();
net.on('joinedRoom', ({ peerId, dataChannel }) => {
    console.log('Room created, waiting for players...');
});

// Or join someone else's room
await net.joinRoom(hostPeerId);
net.on('joinedRoom', ({ peerId, dataChannel }) => {
    console.log('Joined room! Connected via WebRTC');
});
```

### P2P vs WebSocket Mode

| Feature | P2P | WebSocket |
|---------|-----|-----------|
| Server Required | ❌ No | ✅ Yes |
| Discovery | DHT (distributed) | Server list |
| Connection | WebRTC (direct) | WebSocket relay |
| Latency | Low (direct) | Medium (relay) |
| Scalability | Unlimited | Server-limited |
| Setup Complexity | Medium (browser APIs) | Low (server required) |

## SyncSystem - State Synchronization

`SyncSystem` provides a simple way to synchronize state between clients without writing custom sync logic.

### Basic Usage (WebSocket)

```javascript
const net = new ActionNetManager({ url: 'ws://localhost:3000' });

// Create sync system
const sync = new SyncSystem({
    send: (msg) => net.send(msg),
    broadcastInterval: 16,    // Broadcast every 16ms (~60fps)
    staleThreshold: 200        // Consider remote stale after 200ms
});

// Register sync sources
sync.register('player', {
    getFields: () => ({
        score: player.score,
        level: player.level,
        alive: !player.gameOver
    })
});

sync.register('match', {
    getFields: () => ({
        state: matchStateMachine.getState(),
        ready: isReady
    })
});

// Listen for remote updates
sync.on('remoteUpdated', (allRemoteData) => {
    updateOpponentDisplay(allRemoteData.player);
});

sync.on('remoteStale', () => {
    showDisconnectedWarning();
});

sync.on('remoteFresh', () => {
    hideDisconnectedWarning();
});

// Start syncing
sync.start();

// Hook up incoming messages
net.on('syncUpdate', (msg) => {
    sync.handleSyncUpdate(msg);
});

// Query remote data
const remotePlayer = sync.getRemote('player');
if (remotePlayer) {
    opponentScore.text = remotePlayer.score;
}
```

### SyncSystem with P2P

For P2P, pass the dataChannel's send function:

```javascript
const net = new ActionNetManagerP2P({ gameId: 'tetris-1v1' });

const sync = new SyncSystem({
    send: (msg) => {
        const channel = net.getDataChannel();
        if (channel && channel.readyState === 'open') {
            channel.send(JSON.stringify(msg));
        }
    },
    broadcastInterval: 16,
    staleThreshold: 200
});

// Same registration and event handling as above
sync.register('player', { getFields: () => ({...}) });
sync.start();

// For P2P, listen to messages on the data channel directly
const channel = net.getDataChannel();
channel.onmessage = (event) => {
    try {
        const msg = JSON.parse(event.data);
        if (msg.type === 'syncUpdate') {
            sync.handleSyncUpdate(msg);
        }
    } catch (e) {
        console.error('Failed to parse message:', e);
    }
};
```

### SyncSystem API

```javascript
// Register a sync source
sync.register('sourceId', {
    getFields: () => ({ field1: value1, field2: value2 })
});

// Query remote data
sync.getRemote('sourceId')                    // Returns all fields
sync.getRemoteField('sourceId', 'field1')    // Returns single field

// Check connection health
sync.isRemoteStale()          // Boolean
sync.hasRemoteData()          // Boolean
sync.getTimeSinceLastUpdate() // Milliseconds

// Manual control
sync.forceBroadcast()         // Send immediately
sync.clearRemoteData()        // Clear remote state
sync.start()                  // Begin syncing
sync.stop()                   // Stop syncing

// Events
sync.on('remoteUpdated', (data) => {})
sync.on('remoteStale', () => {})
sync.on('remoteFresh', () => {})
```

## Ping and RTT Tracking (WebSocket Only)

ActionNetManager includes built-in ping/pong for latency tracking.

```javascript
const net = new ActionNetManager({
    url: 'ws://localhost:3000',
    pingInterval: 30000,    // Ping every 30 seconds
    pongTimeout: 5000       // Expect pong within 5 seconds
});

// Get current round-trip time
const rtt = net.getRTT();
console.log(`Ping: ${rtt}ms`);

// Listen for RTT updates
net.on('rtt', (rtt) => {
    pingDisplay.text = `${rtt}ms`;
    if (rtt > 200) {
        showLagWarning();
    }
});

// Listen for timeout (pong not received)
net.on('timeout', () => {
    console.warn('Connection timeout - may be disconnected');
});
```

## Auto-Reconnection (WebSocket Only)

ActionNetManager supports automatic reconnection with exponential backoff.

```javascript
const net = new ActionNetManager({
    url: 'ws://localhost:3000',
    reconnect: true,              // Enable auto-reconnect
    reconnectDelay: 1000,         // Start with 1 second delay
    maxReconnectDelay: 30000,     // Cap at 30 seconds
    reconnectAttempts: -1         // -1 = infinite attempts
});

// Listen for reconnection events
net.on('reconnecting', ({ attempt, delay }) => {
    console.log(`Reconnecting... attempt ${attempt} in ${delay}ms`);
    showReconnectingMessage(attempt);
});

net.on('connected', () => {
    console.log('Reconnected!');
    hideReconnectingMessage();
});

net.on('reconnectFailed', () => {
    console.log('Max reconnect attempts reached');
    showConnectionFailedMessage();
});

// Get current reconnect attempt count
const attempts = net.getReconnectAttempts();
console.log(`Reconnect attempts: ${attempts}`);
```

### Exponential Backoff

Reconnect delays increase exponentially:
- Attempt 1: 1 second
- Attempt 2: 2 seconds
- Attempt 3: 4 seconds
- Attempt 4: 8 seconds
- Attempt 5: 16 seconds
- Attempt 6+: 30 seconds (capped at maxReconnectDelay)

## Host System

The first person to join a room becomes the host. This is useful for peer selection, game flow control, or special privileges.

### Client API

```javascript
// Check if current user is the host
if (net.isCurrentUserHost()) {
    console.log('You are the host - you can start the game!');
    showStartButton();
}

// Get the host's info
const host = net.getHost();
if (host) {
    console.log('Host:', host.displayName);
}

// Listen for host leaving (only guests receive this)
net.on('hostLeft', (msg) => {
    console.log('Host left - returning to lobby');
    showLobbyScreen();
});
```

### Server API

```javascript
const utils = new ActionNetServerUtils(wss);

// Check if a client is the host
if (utils.isHost(ws)) {
    console.log('This client is the host!');
}

// Get host info for a room
const host = utils.getHostOfRoom('game-room-1');
if (host) {
    console.log('Host:', host.displayName);
}
```

## Best Practices

### ✅ DO:
```javascript
// Use displayName for anything users see
chatMessage.text = `${user.displayName}: ${text}`;
userListItem.text = user.displayName;
scoreboard.add(user.displayName, score);

// Use client ID for internal tracking
playerData[user.id] = { score: 100 };
entityMap.set(user.id, entity);

// Check host status for game logic
if (net.isCurrentUserHost()) {
    // Only host can start the game
    showStartButton();
}

// Use SyncSystem for continuous state
sync.register('position', {
    getFields: () => ({ x: player.x, y: player.y })
});

// Use custom messages for one-shot events
net.send({ type: 'attack', damage: 10 });
```

### ❌ DON'T:
```javascript
// Don't show client IDs to users
chat.addMessage(client.id, text);  // Shows "client_1234567890" - confusing!

// Don't use usernames as unique keys
playerData[client.username] = data;  // Can conflict if names aren't unique!

// Don't confuse username and displayName
chat.text = client.username;        // Use displayName instead!

// Don't sync everything constantly
sync.register('everything', {
    getFields: () => game.entireState  // Too much data!
});
```

## Server Setup

### WebSocket Server (Node.js)

```javascript
const WebSocket = require('ws');
const ActionNetServerUtils = require('./ActionNetServerUtils');

const wss = new WebSocket.Server({ port: 3000 });
const utils = new ActionNetServerUtils(wss);

wss.on('connection', (ws) => {
    ws.on('message', (data) => {
        const msg = JSON.parse(data.toString());
        
        if (msg.type === 'connect') {
            // Register client - automatically generates unique displayName
            utils.registerClient(ws, msg);
            const client = utils.getClient(ws);
            
            // Send confirmation
            ws.send(JSON.stringify({
                type: 'connectSuccess',
                clientId: client.id,
                displayName: client.displayName
            }));
            
            // Broadcast room list
            utils.broadcastToAllClients({
                type: 'roomList',
                rooms: utils.getAvailableRooms()
            });
        }
        
        if (msg.type === 'joinRoom') {
            utils.addToRoom(ws, msg.roomName);
            const client = utils.getClient(ws);
            
            ws.send(JSON.stringify({
                type: 'joinSuccess',
                roomName: msg.roomName
            }));
            
            // Notify room members
            utils.broadcastToRoom(msg.roomName, {
                type: 'userJoined',
                id: client.id,
                displayName: client.displayName,
                isHost: utils.isHost(ws)
            });
            
            // Send user list to joiner
            const users = utils.getClientsInRoom(msg.roomName).map(c => ({
                id: c.id,
                displayName: c.displayName,
                isHost: utils.isHost(ws) && utils.getHostOfRoom(msg.roomName) === ws
            }));
            
            ws.send(JSON.stringify({
                type: 'userList',
                users: users
            }));
        }
        
        if (msg.type === 'leaveRoom') {
            const client = utils.getClient(ws);
            const wasHost = utils.isHost(ws);
            
            utils.removeFromRoom(ws);
            
            if (wasHost) {
                // Host left - close room
                utils.broadcastToRoom(client.roomName, {
                    type: 'hostLeft',
                    displayName: client.displayName
                });
                utils.closeRoom(client.roomName);
            } else {
                // Guest left - notify room
                utils.broadcastToRoom(client.roomName, {
                    type: 'userLeft',
                    id: client.id,
                    displayName: client.displayName
                });
            }
        }
    });
    
    ws.on('close', () => {
        const client = utils.getClient(ws);
        if (client) {
            const wasHost = utils.isHost(ws);
            utils.unregisterClient(ws);
            
            if (wasHost && client.roomName) {
                // Host disconnected - close room
                utils.broadcastToRoom(client.roomName, {
                    type: 'hostLeft',
                    displayName: client.displayName
                });
                utils.closeRoom(client.roomName);
            }
        }
    });
});
```

## API Reference

### ActionNetManager (WebSocket Client)

#### Connection
```javascript
net.connectToServer({ username: 'Bob' })     // Returns Promise
net.disconnect()
net.isConnected()                             // Returns Boolean
net.connectionFailed()                        // Returns Boolean
net.testServerConnection()                    // Returns Promise<{available, error}>
```

#### Room Management
```javascript
net.joinRoom('lobby')                         // Returns Promise
net.leaveRoom()
net.isInRoom()                                // Returns Boolean
net.getCurrentRoomName()                      // Returns String|null
net.getAvailableRooms()                       // Returns Array<String>
```

#### Identity
```javascript
net.getClientId()                             // Returns String (unique ID)
net.getUsername()                             // Returns String (user-provided)
net.setUsername(name)                         // Returns Promise
```

#### Host System
```javascript
net.isCurrentUserHost()                       // Returns Boolean
net.getHost()                                 // Returns {id, displayName, isHost}
```

#### Messaging
```javascript
net.send(message)                             // Returns Boolean
net.getNewMessages()                          // Returns Array (polling pattern)
```

#### Latency (WebSocket only)
```javascript
net.getRTT()                                  // Returns Number (milliseconds)
net.getReconnectAttempts()                    // Returns Number
```

#### Connected Users
```javascript
net.getConnectedUsers()                       // Returns Array<{id, displayName, isHost}>
```

### ActionNetManagerP2P (P2P Client)

#### Game Management
```javascript
net.joinGame(gameId, username)                // Returns Promise
net.createRoom()
net.joinRoom(hostPeerId)                      // Returns Promise
net.leaveRoom()
net.disconnect()                              // Returns Promise
```

#### State
```javascript
net.isConnected()                             // Returns Boolean
net.isInRoom()                                // Returns Boolean
net.isCurrentUserHost()                       // Returns Boolean
```

#### Identity
```javascript
net.getUsername()                             // Returns String
net.setUsername(name)                         // Returns Promise
```

#### Data
```javascript
net.getDataChannel()                          // Returns RTCDataChannel|null
net.getAvailableRooms()                       // Returns Array<{peerId, username, displayName, currentPlayers, maxPlayers, slots}>
net.getConnectedUsers()                       // Returns Array<{id, displayName, isHost}>
net.getConnectedPeerCount()                   // Returns Number (direct connections)
net.getDiscoveredPeerCount()                  // Returns Number (DHT peers)
```

#### Host-specific (Host only)
```javascript
net.acceptJoin(peerId)                        // Accept pending join request
```

### ActionNetManagerGUI (UI Bridge)

#### Setup
```javascript
// WebSocket mode
const gui = new ActionNetManagerGUI(canvases, input, audio, 8000);

// P2P mode
const gui = new ActionNetManagerGUI(canvases, input, audio, { mode: 'p2p' });
```

#### Update & Render
```javascript
gui.action_update(deltaTime)
gui.action_draw()
```

#### Access
```javascript
gui.getNetManager()                           // Returns ActionNetManager or ActionNetManagerP2P
gui.getUsername()                             // Returns String
gui.isConnected()                             // Returns Boolean
gui.isInRoom()                                // Returns Boolean
```

#### SyncSystem
```javascript
gui.syncSystem                                // Access SyncSystem instance
gui.activateSyncForRoom()                     // Start syncing when room joined
gui.deactivateSyncForRoom()                   // Stop syncing when room left
```

#### Custom Messages
```javascript
gui.registerMessageHandler('myEvent', (msg) => {
    // Handle custom message
});

gui.unregisterMessageHandler('myEvent')
```

#### Events
```javascript
gui.on('joinedRoom', (roomName) => {})
gui.on('leftRoom', (roomName) => {})
gui.on('buttonPressed', () => {})
gui.on('back', () => {})
gui.on('selectionChanged', ({oldIndex, newIndex}) => {})
gui.on('disconnected', () => {})
```

### ActionNetServerUtils (Server Utilities)

#### Client Management
```javascript
utils.registerClient(ws, {username, clientId, ...metadata})
utils.unregisterClient(ws)
utils.getClient(ws)                           // Returns {id, username, displayName, roomName}
```

#### Room Management
```javascript
utils.addToRoom(ws, roomName)                 // Returns Boolean
utils.removeFromRoom(ws)
utils.closeRoom(roomName)
utils.getClientsInRoom(roomName)              // Returns Array of client objects
utils.getAvailableRooms()                     // Returns Array<String>
```

#### Broadcasting
```javascript
utils.broadcastToRoom(roomName, message)      // Send to room members
utils.broadcastToAllClients(message)          // Send to everyone
```

#### Host System
```javascript
utils.isHost(ws)                              // Returns Boolean
utils.getHostOfRoom(roomName)                 // Returns client object or null
```

#### Display Names
```javascript
utils.generateUniqueDisplayName(username, excludeId)  // Returns String
```

### SyncSystem

#### Registration
```javascript
sync.register(sourceId, {
    getFields: () => ({ field1, field2 })
})

sync.unregister(sourceId)
```

#### Query
```javascript
sync.getRemote(sourceId)                      // Returns Object|null
sync.getRemoteField(sourceId, field)          // Returns Any|null
sync.getAllRemote()                           // Returns Object
```

#### State Checks
```javascript
sync.isRemoteStale()                          // Returns Boolean
sync.hasRemoteData()                          // Returns Boolean
sync.getTimeSinceLastUpdate()                 // Returns Number (ms)
sync.getRegisteredSources()                   // Returns Array<String>
```

#### Manual Control
```javascript
sync.forceBroadcast()                         // Broadcast immediately
sync.clearRemoteData()                        // Clear remote state
sync.handleSyncUpdate(message)                // Process incoming sync
sync.start()                                  // Begin syncing
sync.stop()                                   // Stop syncing
sync.setSendFunction(fn)                      // Change transport
```

#### Events
```javascript
sync.on('remoteUpdated', (allRemoteData) => {})
sync.on('remoteStale', () => {})
sync.on('remoteFresh', () => {})
sync.on('broadcast', (localData) => {})
```

## Events Reference

### ActionNetManager Events

- `connected`: `() => {}` - Connected to server
- `disconnected`: `() => {}` - Disconnected from server
- `error`: `(error) => {}` - Connection or server error
- `message`: `(msg) => {}` - Any message received
- `roomList`: `(rooms) => {}` - Available rooms updated
- `userList`: `(users) => {}` - Users in room updated
- `joinedRoom`: `(roomName) => {}` - Successfully joined room
- `leftRoom`: `(roomName) => {}` - Left room
- `userJoined`: `(user) => {}` - Someone joined your room
- `userLeft`: `(user) => {}` - Someone left your room
- `hostLeft`: `(msg) => {}` - Host left, room closing
- `usernameChanged`: `({oldUsername, newUsername, displayName}) => {}` - Username changed
- `chat`: `(msg) => {}` - Chat message received
- `system`: `(msg) => {}` - System message received
- `rtt`: `(milliseconds) => {}` - Round-trip time updated
- `timeout`: `() => {}` - Pong not received (connection issue)
- `reconnecting`: `({attempt, delay}) => {}` - Attempting to reconnect
- `reconnectFailed`: `() => {}` - Max reconnect attempts reached
- Custom events based on `message.type`

### ActionNetManagerP2P Events

- `connected`: `() => {}` - Joined DHT network
- `disconnected`: `() => {}` - Disconnected from DHT
- `error`: `(error) => {}` - Connection error
- `roomList`: `(rooms) => {}` - Available rooms updated
- `userList`: `(users) => {}` - Users in room updated
- `joinedRoom`: `({peerId, dataChannel}) => {}` - Joined/created room
- `leftRoom`: `(peerId) => {}` - Left room
- `userJoined`: `(user) => {}` - Someone joined your room
- `userLeft`: `(user) => {}` - Someone left your room
- `hostLeft`: `({peerId}) => {}` - Host left (guests only)
- `guestLeft`: `({peerId}) => {}` - Guest left (host only)
- `joinRequest`: `({peerId, username}) => {}` - Join request received (host only)
- `joinAccepted`: `({peerId, users}) => {}` - Join accepted by host (guest only)
- `joinRejected`: `({peerId, reason}) => {}` - Join rejected by host (guest only)
- `usernameChanged`: `({oldUsername, newUsername, displayName}) => {}` - Username changed
- `peerHandshook`: `({peerId, username}) => {}` - Initial handshake completed

### ActionNetManagerGUI Events

- `joinedRoom`: `(roomName) => {}` - Joined room
- `leftRoom`: `(roomName) => {}` - Left room
- `buttonPressed`: `() => {}` - Button pressed (for sound effects)
- `back`: `() => {}` - Back button pressed
- `backToLogin`: `() => {}` - Back to login screen
- `selectionChanged`: `({oldIndex, newIndex}) => {}` - Selection changed
- `disconnected`: `() => {}` - Network disconnected
- `message:{type}`: `(msg) => {}` - Custom message (emitted for unhandled types)

### SyncSystem Events

- `remoteUpdated`: `(remoteData) => {}` - Remote data received
- `remoteStale`: `() => {}` - Remote stopped sending updates
- `remoteFresh`: `() => {}` - Remote resumed after being stale
- `broadcast`: `(localData) => {}` - We broadcasted data

## See Also

- Server example: `game/server/ActionNetServer.js`
- Server README: `game/server/README.md`
- Run server: `game/server/start.bat` (Windows) or `game/server/start.sh` (Mac/Linux)
